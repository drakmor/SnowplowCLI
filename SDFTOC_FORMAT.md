# SDFTOC (Snowdrop) v0x2A — формат по коду

Документ основан **на предоставленных функциях** (`sub_F7C700`, `sub_F7A130`, `sub_F7A3D0`, `sub_FADBC0`, `sub_FA8020`, `sub_23FB30` и зависимостях). Там, где поля неизвестны по смыслу, они описаны как блоки фиксированного размера и в порядке чтения.

## Общая схема (порядок чтения)

```
[Header0 0x30]
[Header1 0x30]
[flag0][flag1]
[+0x140 extra если flag0!=0]
[Block A: 8*countA]
[Block B: 4*countB]
[Block C: 48*countB]
[Block D: 8*countB]
[Block DDS: 152*ddsHeaderCount]
[Block FT: compressedFileTableSize]
[Footer 0x30]
```

`countB` соответствует количеству "dataslice" (см. `MF_SDF_DATASLICE_MAX_INDEX`), а суммарный размер блоков B/C/D = **60 * countB**.

Формула проверки размера файла из `sub_F7C700`:

```
fileSize == headerSize
         + (8 * countA)
         + (60 * countB)
         + (152 * ddsHeaderCount)
         + compressedFileTableSize
```

`headerSize = 206` если `flag0==0`, иначе `526`.
Блоки A/B/C/D начинаются с позиции `headerSize - 0x30` (учёт footer).

## Header0 (0x30)
Из `sub_F7C700`:
- проверка magic `WEST` (и альтернативной сигнатуры),
- проверка `version == 0x2A`,
- поле `fileSize` используется для валидации.

Точное разложение всех полей неизвестно, но **минимум** включает magic, version и общий размер файла.

## Header1 (0x30)
Из `sub_F7C700` используются следующие поля:
- `compressedFileTableSize` (`n0x8000[0]`) — размер **сжатой** таблицы файлов
- `ddsHeaderCount` (`v94`) — количество DDS‑записей
- `countA` (`v81`) — число записей блока A по 8 байт (используется `sub_F7A130`)
- `countB` = `MF_SDF_DATASLICE_MAX_INDEX + 1`

Также читаются дополнительные поля (`v42`, `v92`) — используются только для расчёта размеров/валидности.

## Флаги
После двух заголовков читаются два байта:

- `flag0` (byte): если `!=0`, сразу после флагов идёт **доп. блок 0x140 байт**
- `flag1` (byte): признак **шифрования** таблицы файлов

## Block A: таблица 8‑байтовых записей
В v0x2A `countA` соответствует `installPartCount` из заголовка. Читается `countA` записей по 8 байт:

```
struct EntryA {
  u32 key;
  u32 value;
}
```

`sub_F7A130` строит по этим данным hash‑таблицу (по ключу). Семантика ключа не определена из кода.

## Blocks B/C/D: dataslice таблицы (countB)
`countB` определяется как:

```
countB = sub_F7A4E0("MF_SDF_DATASLICE_MAX_INDEX") + 1
```

Дальше читаются **три массива**:
- `4 * countB` байт
- `48 * countB` байт
- `8 * countB` байт

В сумме: **60 байт на элемент**. Точный формат полей не определён, но порядок чтения фиксирован.

## DDS header block
Количество = `ddsHeaderCount`. Размер записи = **152 байта**:

```
struct DDSHeader {
  u32 unk;
  u8  data[0x94];
}
```

## Таблица файлов (File Table)
Размер — `compressedFileTableSize`.

- Если `flag1 == 0`: таблица — **deflate/zlib** (поддержка gzip в `sub_FADBC0`).
- Если `flag1 != 0`: таблица **сначала расшифровывается**, затем распаковывается.

### Расшифровка (flag1)
1) **TEA/XTEA‑подобная** расшифровка первого 8‑байтного блока:
   - delta `0x61C88647`
   - key `{ 0x0B, 0x11, 0x17, 0x1F }`

2) **DES‑PCBC** всего буфера:
   - ключ и IV получают через `sub_23FA30`
   - `byte_86812E0` → ключ
   - `byte_8681330` → IV

В инструменте ключи подаются через CLI:

```
--key=<строка>   или --key=hex:<HEX>
--iv=<строка>    или --iv=hex:<HEX>
```

## Footer (0x30)
В конце файла читается блок 0x30 и проверяются строки:

- `evissam` ("massive" в обратном порядке)
- `tfosibu` ("ubisoft" в обратном порядке)

Это используется как целостность/валидация.

## Примечания
- Значения `countA`, `countB`, `ddsHeaderCount` и `compressedFileTableSize` приходят из заголовков (Header1).
- В v0x2A в заголовке `compressedFileTableSize` может быть 0 — фактический размер берётся из `dataOffset`.
- Если `countB` не извлечён через hash‑таблицу, его можно вычислить из формулы размера файла.
- Точная семантика блоков A/B/C/D пока неизвестна, но порядок и размеры подтверждены кодом чтения.
